import java.io.*;import java.util.Observer;import java.util.Observable;import com.lloseng.ocsf.server.*;import common.ChatIF;/** * This class overrides some of the methods in the abstract superclass in order * to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {	// Class variables *************************************************	/**	 * The default port to listen on.	 */	final public static int DEFAULT_PORT = 5555;		ChatIF serverUI;		ObservableServer observableServer;	// Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port The port number to connect on.	 */	public EchoServer(int port, ChatIF serverUI) {		this.serverUI = serverUI;		observableServer = new ObservableOriginatorServer(port);		observableServer.addObserver(this);	}	// Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 *	 * @param msg    The message received from the client.	 * @param client The connection from which the message originated.	 */	public void handleMessageFromClient(Object msg, ConnectionToClient client) {		String[] args = ((String) msg).split(" ");		String command = args[0];		serverUI.display(command);				if( (boolean)client.getInfo("justMakeConnection") &&  !command.equals("#login")) {			try {				client.sendToClient("ERREUR | give our id before making command");				client.close();			} catch (IOException e) {				e.printStackTrace();			}		}		else {			switch (command) {			case "#quit":				try {					client.close();				} catch (IOException e) {					e.printStackTrace();				}				break;			case "#logoff":				try {					client.close();				} catch (IOException e) {					e.printStackTrace();				}				break;			case "#login" :				if ((boolean)client.getInfo("justMakeConnection")) {					serverUI.display(args[1]);					client.setInfo("id", args[1]);					serverUI.display("Client with id: " + client.getInfo("id"));					client.setInfo("justMakeConnection", false);				}				else {					try {						client.sendToClient("ERREUR | your already connected");					} catch (IOException e) {						e.printStackTrace();					}				}				break;			default:				serverUI.display("Message received: " + msg + " from " + client.getInfo("id"));				observableServer.sendToAllClients(client.getInfo("id") + " - " + msg);			}		}	}			/**	 * This method handles any messages received from the server.	 *	 * @param msg    The message received from the server.	 */	public void handleMessageFromServerUI(Object msg) {		String[] args = ((String) msg).split(" ");		String command = args[0];		switch (command) {		case "#start":			if (observableServer.isListening()) {				serverUI.display("server already started");			} else {				try {					observableServer.listen(); // Start listening for connections				} catch (Exception ex) {					System.out.println("ERROR - Could not listen for clients!");				}			}			break;		case "#quit":			try {				observableServer.close();				System.exit(0);			} catch (IOException e) {				e.printStackTrace();			}			break;		case "#stop":			observableServer.stopListening();			break;		case "#close":			try {				observableServer.sendToAllClients("#logoff");				observableServer.close();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}			break;		case "#setport":			if (observableServer.isListening()) {				serverUI.display("Cannot set port if server is listening");			} else {				observableServer.setPort(Integer.parseInt(args[1]));				serverUI.display("Port has been set to " + observableServer.getPort());			}			break;		case "#getport":			serverUI.display("Your port is " + observableServer.getPort());			break;		default:			serverUI.display(msg.toString());			observableServer.sendToAllClients("server msg > " + msg);		}	}	/**	 * This method overrides the one in the superclass. Called when the server	 * starts listening for connections.	 */	protected void serverStarted() {		serverUI.display("Server listening for connections on port " + observableServer.getPort());	}	/**	 * This method overrides the one in the superclass. Called when the server stops	 * listening for connections.	 */	protected void serverStopped() {		serverUI.display("Server has stopped listening for connections.");	}		/**	 * This method overrides the one in the superclass. Called when the server closes	 * listening for connections.	 */	protected void serverClosed() {		serverUI.display("Server has closed listening for connections.");	}		protected void listeningException (Throwable exception) {		serverUI.display("Error on listening.");	}	// Hook methods ***************************************************	public void clientConnected(ConnectionToClient client) {		serverUI.display("A client is connected !");		client.setInfo("justMakeConnection", true);	}	synchronized public void clientDisconnected(ConnectionToClient client) {		serverUI.display("| SystemServer | --> a client closed his connection !");	}	synchronized protected void clientException(ConnectionToClient client, Throwable exception) {		serverUI.display("| SystemServer | --> a client is disconnected suddenly !");	}	// Class methods ***************************************************	/**	 * This method is responsible for the creation of the server instance (there is	 * no UI in this phase).	 *	 * @param args[0] The port number to listen on. Defaults to 5555 if no argument	 *                is entered.	 */	public static void main(String[] args) {		int port = 0; // Port to listen on		try {			port = Integer.parseInt(args[0]); // Get port from command line		} catch (Throwable t) {			port = DEFAULT_PORT; // Set port to 5555		}		try {			EchoServer sv = new EchoServer(port, null);			} catch (Exception ex) {			System.out.println("ERROR - Could not listen for clients!");		}	}	@Override	public void update(Observable arg0, Object arg1) {		// TODO Auto-generated method stub		OriginatorMessage originatorMessage = (OriginatorMessage) arg1;		if (originatorMessage.getMessage().equals(ObservableServer.CLIENT_CONNECTED)) {			clientConnected(originatorMessage.getOriginator());		} else if (originatorMessage.getMessage().equals(ObservableServer.CLIENT_DISCONNECTED)) {			clientDisconnected(originatorMessage.getOriginator());		} else if (originatorMessage.getMessage().equals(ObservableServer.SERVER_STARTED)) {			serverStarted();		} else if (originatorMessage.getMessage().equals(ObservableServer.SERVER_CLOSED)) {			serverClosed();		} else if (originatorMessage.getMessage().equals(ObservableServer.SERVER_STOPPED)) {			serverStopped();		} else if (originatorMessage.getMessage().equals(ObservableServer.LISTENING_EXCEPTION)) {			listeningException(new Exception(originatorMessage.toString().substring(ObservableServer.CLIENT_EXCEPTION.toString().length())));		} else if (originatorMessage.getMessage().equals(ObservableServer.CLIENT_EXCEPTION)) {			clientException(originatorMessage.getOriginator(), 					new Exception(originatorMessage.toString().substring(ObservableServer.CLIENT_EXCEPTION.toString().length())));		} else {			handleMessageFromClient(originatorMessage.getMessage(), originatorMessage.getOriginator());		}	}}//End of EchoServer class